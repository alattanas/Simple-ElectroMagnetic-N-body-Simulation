# Electrostatic and Gravitational N-body Simulation

#### Description:
This code performs simple N-body simulations of particles incorporating gravity effects of their mass as well as the electrostatic contributions of their charge if included. The main function where systems are set up is in the "electrostatic_N_body.py" file where some configurations are commented out for ease of use. The resulting motion is incorporated as 1st order approximations of the velocity and 2nd order approximations of the positon where the velocity is capped at a maximum of 95% of the speed of light to avoid the need for more computationally intensive relativistic velocity additions. Aside from two included initial particle distributions the system is not evaluated on a gridded domain but instead evaluated in 3-space where the only determining factor is the chosen timestep. As a result numerical instabilities are not addressed or investigated and the more complicated task of determining collisions is ommitted.

The output of these simulations is only stored and returned in memory, not written to a file for more permanent storage, as an instance of a system class which included a tictionary whose keys are timestep indeces and whose entries are instances of charged_particles containing their location and velocities at that timestep. In addition to returning the time-development as a system class variable the results are by default visualized as an animation which is then saved in the local directory as "animation.gif" and "animation.mp4" 

## Charge initialization
Initial configurations of the particles is done with functions in the   charge_init.py file which has functions to initially determine a gridded domain for use of interpolating optional particle distributions, generating position arrays of particle distributions as spheres, shells or 2-particle systems, and initializing particles at each of those locations. When initialized, each particle by default is treated as an electron in terms of charge and mass. After this particle initialization options of modifying and randomizing particle properties can be done using the randomize_properties() function by specifying the version number for the change. The options are as followed and not mutually exclusive:

1. Invert the charge polarity of half the particles chosen at random.
2. Randomize the order of magnitude of the mass of each particle between 10^-5 and 10^15 kg.
3. Remove the charge of half of the particles chosen at random.
4. Remove the charge from all particles to have an exclusively gravitational N-body system.
5. Set the masses of all particles to either 1000 kg by default or the value of an optional input.
6. Set the masses of all particles to 0 kg for an exclusively elextrostatic N-body system.
7. Randomize the initial velocity of all particles to have cartesian components between -10 and 10 m/s.

## System Development
The charge_class.py file includes definitions of classes for the total system as well as individual charges. The initial charge configuration is determined in the initiation stage where a dictionary of charge instances is made which is then used to initialize the system. The system instance stores the particle configuration at the end of a timestep as a new dictionary entry so that the properties of the system at any point in time can be inspected independently of previous arrangements. To determine how the next timestep configuration should be the previous timestep's particle instances are first deep-copied in the system's method "progress_time()". Then for each particle in the system, the electrostatic lorentz force and gravitational force acting on it is calculated for every other particle in the system as well as any forces imparted by a static ambient electric field. This is done by iterating over each particle and calling the "_develop_forces()" method which in turn iterates over each other particle and calls a "_calc_lorentz()" method to find the force of a single other particle on the current one. 

Once the total forces are found for each particle, the acceleration of each particle is calculated in the method defined in the point_charge class which is then used to determine the velocity of the particle at then end of the timestep. The next velocity value is found using a 1st order approximation of Newton's velocity equation of motion, and the next cartesian position using a 2nd order approximation of the Newtonian exuation of motion. The position formulation includes the quadratic time term with accelration instead of just the linear change using only velocity to improve the system's accuracy. This increases computational resources but allows for larger timestep values because the development isn't dependent on timesteps being small enough to make motion approximately linear. Once the new spatial properties are calculated for every particle they are used to update the position and velocity of each particle, using the particle's "_update_loc()" method, which are then stored in a new dictionary entry in the system in the timedev variable. An additional dictionary called timealias in the system instance is updated to include the time in seconds associated with the timestep index keyed to the timedev dictionary.

## Visualization
After the N-body simulation is evaluated for the number of timesteps specified, a plotting function called animate_pos is used to visualize the development. This uses the celluloid package's camera function which stores the configuration of particles for each timestep included in the system's timedev dictionary. In this animation the particles are color-coded to indicate primarily charge, such that negative particles are blue, positive particles are red and neutral particles are grey. For the non-physical option of setting particle mass to 0 kg the particles are shown as yellow. Due to potentially non-obvious package dependencies the resulting animation is stored not just as a .mp4 file with the filename "animation.mp4" but also as "animation.gif". There is not at this time a user interface to specify which version to make so both will be attempted. Since the visualization is the resource heavy part of this code for small-many body simulations under a few hundred particles it may be undesirable to visualize the results every time and so the plotting function is called only optionally.

The domain size of the system is theoretically infinite without a bounding box to contain the particles. This means that the visualization of the system may not include all of the particles at all times if a specific spatial scale is wanted. An optional input of the axis limits is available for this reason. To include the option of scaling the plot axis limits include to the farthest reaching particles the largest domain sizes are checked and updated for each timestep and stored as a property of the system instance. This range is then optionally used to scale the entirety of the animation's domain size.
